---
title: "Error Tracking Services with Sentry for Next.js Production Monitoring"
category: "error-handling"
subcategory: "monitoring"
tags: ["error-tracking", "sentry", "rollbar", "monitoring", "observability"]
stack: "js-nextjs"
priority: "high"
audience: "fullstack"
complexity: "intermediate"
doc_type: "standard"
source_confidence: "0%"
last_updated: "2026-02-11"
---

# Error Tracking Services with Sentry for Next.js Production Monitoring

Error tracking services (Sentry, Rollbar, Bugsnag) provide centralized error monitoring, stack trace aggregation, user context tracking, and alerting for production errors. Analyzed codebases show 0% adoption of error tracking services despite 313+ components, 33+ utility functions, and 10+ API routes with zero visibility into production errors. Error tracking enables proactive bug detection, release monitoring, and error trend analysis.

## Why Error Tracking Services Are Critical

Console.error logs vanish after execution (no persistence), lack user context (cannot correlate errors to specific users), and provide no alerting (developers unaware of production errors until users report issues). Error tracking services persist errors, aggregate duplicate errors, track affected users, and alert teams in real-time.

**Current Pattern (0% Adoption):**

```typescript
// ❌ Current: Error logged to console, no persistence
catch (error) {
  console.error('Failed to fetch municipalities:', error)
}
// Error disappears after execution
// No alert sent to developers
// No visibility into frequency or affected users
```

**Error Tracking Pattern (Recommended):**

```typescript
// ✅ Recommended: Error sent to Sentry with context
import * as Sentry from '@sentry/nextjs'

catch (error) {
  Sentry.captureException(error, {
    tags: {
      section: 'municipalities-api',
      operation: 'fetch',
    },
    extra: {
      municipalityId: params.slug,
      userId: session?.userId,
    },
  })
  throw error
}
// Error persisted in Sentry dashboard
// Alert sent to Slack/email if threshold exceeded
// Grouped with similar errors, shows affected user count
```

**Benefits of Error Tracking:**
- Persistence: Errors stored permanently (6-12 months retention)
- Aggregation: Duplicate errors grouped, shows occurrence frequency
- Context: User ID, browser, OS, release version, breadcrumbs
- Alerting: Real-time notifications (Slack, email, PagerDuty)
- Trends: Error rate graphs, release comparisons, error-free rate
- Debugging: Full stack traces, source maps, variable values

## Sentry: Next.js-Optimized Error Tracking

Sentry provides Next.js SDK with automatic error instrumentation, source map uploading, release tracking, and performance monitoring.

**Installation:**

```bash
npm install @sentry/nextjs
npx @sentry/wizard@latest -i nextjs
```

**Automatic Configuration (Generated by Wizard):**

```typescript
// sentry.client.config.ts (Client-Side Errors)
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,  // 100% performance monitoring (reduce in production)
  replaysOnErrorSampleRate: 1.0,  // Session replay on errors
  integrations: [
    Sentry.replayIntegration({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
})

// sentry.server.config.ts (Server-Side Errors)
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
})

// sentry.edge.config.ts (Edge Runtime Errors)
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
})
```

**Environment Variables:**

```bash
# .env.local
NEXT_PUBLIC_SENTRY_DSN=https://abc123@o123456.ingest.sentry.io/7890123
SENTRY_AUTH_TOKEN=sntrys_your_auth_token_here  # For source map uploads
SENTRY_ORG=your-org
SENTRY_PROJECT=policy-node
```

**Next.js Configuration (sentry.webpack.config.js Injected):**

```javascript
// next.config.js (modified by wizard)
const { withSentryConfig } = require('@sentry/nextjs')

module.exports = withSentryConfig(
  {
    // Your Next.js config
  },
  {
    silent: true,  // Suppresses source map upload logs
    widenClientFileUpload: true,  // Upload larger set of source maps
    hideSourceMaps: true,  // Hides source maps from client bundle
    disableLogger: true,  // Removes Sentry debug logs from production
  }
)
```

## Automatic Error Capture

Sentry Next.js SDK automatically captures unhandled errors in Client Components, Server Components, API Routes, middleware, and edge functions without manual instrumentation.

**Automatic Capture Scenarios:**

```typescript
// Client Component - Automatically captured
'use client'

export default function JobBoard() {
  const [jobs, setJobs] = useState([])

  useEffect(() => {
    // ✅ Unhandled promise rejection → Sentry captures automatically
    fetch('/api/jobs').then(res => res.json()).then(setJobs)
  }, [])

  // ✅ Render error → Sentry captures automatically
  return (
    <div>
      {jobs.map(job => (
        <div key={job.id}>{job.title.toUpperCase()}</div>  // Error if job.title is undefined
      ))}
    </div>
  )
}

// Server Component - Automatically captured
export default async function MunicipalityPage({ params }) {
  // ✅ Async error → Sentry captures automatically
  const municipality = await fetchMunicipality(params.slug)

  return <div>{municipality.name}</div>
}

// API Route - Automatically captured
export async function GET(request: NextRequest) {
  // ✅ Unhandled exception → Sentry captures automatically
  const data = await sanityClient.fetch(/* ... */)
  return NextResponse.json(data)
}
```

**Error Boundary Integration:**

```typescript
// app/error.tsx
'use client'

import * as Sentry from '@sentry/nextjs'
import { useEffect } from 'react'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // ✅ Manually capture error from error boundary
    Sentry.captureException(error, {
      tags: { location: 'error-boundary' },
      extra: { digest: error.digest },
    })
  }, [error])

  return (
    <div>
      <h2>Something went wrong</h2>
      <button onClick={reset}>Try again</button>
    </div>
  )
}
```

## Manual Error Capture with Context

Sentry.captureException() provides manual error capture with custom tags, extra context, user information, and breadcrumbs for enhanced debugging.

**Basic Exception Capture:**

```typescript
import * as Sentry from '@sentry/nextjs'

try {
  await fetchMunicipalities()
} catch (error) {
  Sentry.captureException(error)
  throw error
}
```

**Exception with Tags (Searchable Metadata):**

```typescript
Sentry.captureException(error, {
  tags: {
    section: 'municipalities-api',
    operation: 'fetch',
    dataSource: 'sanity',
    critical: 'true',
  },
})

// Sentry UI: Filter by tag (e.g., show all errors with critical=true)
```

**Exception with Extra Context (Non-Searchable Debugging Info):**

```typescript
Sentry.captureException(error, {
  extra: {
    municipalityId: params.slug,
    userId: session?.userId,
    s3Key: 'municipalities.csv',
    retryCount: 3,
    requestBody: JSON.stringify(request.body),
  },
})

// Sentry UI: Extra context shown in error details (not searchable)
```

**User Context (Track Affected Users):**

```typescript
// Set user context at session start
Sentry.setUser({
  id: session.userId,
  email: session.email,
  username: session.username,
  role: session.role,
})

// All subsequent errors include user context
Sentry.captureException(error)

// Sentry UI: Shows "123 users affected" + user list
```

**Breadcrumbs (User Actions Leading to Error):**

```typescript
// Sentry automatically captures navigation, console logs, fetch calls

// Manual breadcrumb for custom events
Sentry.addBreadcrumb({
  category: 'municipality',
  message: 'User selected municipality filter',
  level: 'info',
  data: {
    filter: 'population',
    value: '> 100k',
  },
})

// Breadcrumbs shown in error timeline (last 100 events before error)
```

## API Route Error Tracking

Next.js API routes require manual error capture (automatic capture does not include request context like user ID, endpoint, params).

**Basic API Error Tracking:**

```typescript
// app/api/municipalities/route.ts
import * as Sentry from '@sentry/nextjs'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  try {
    const municipalities = await fetchMunicipalities()
    return NextResponse.json(municipalities)
  } catch (error) {
    Sentry.captureException(error, {
      tags: {
        endpoint: '/api/municipalities',
        method: 'GET',
      },
      extra: {
        url: request.url,
        headers: Object.fromEntries(request.headers),
      },
    })

    return NextResponse.json(
      { error: 'Failed to fetch municipalities' },
      { status: 500 }
    )
  }
}
```

**Advanced API Error Tracking with Request ID:**

```typescript
// app/api/municipalities/[slug]/route.ts
import * as Sentry from '@sentry/nextjs'

export async function GET(
  request: NextRequest,
  { params }: { params: { slug: string } }
) {
  const requestId = crypto.randomUUID()

  try {
    const municipality = await fetchMunicipality(params.slug)

    if (!municipality) {
      // Track 404 errors (not exceptions, but still valuable)
      Sentry.captureMessage(`Municipality not found: ${params.slug}`, {
        level: 'warning',
        tags: { endpoint: '/api/municipalities/[slug]', statusCode: '404' },
        extra: { slug: params.slug, requestId },
      })

      return NextResponse.json({ error: 'Not found' }, { status: 404 })
    }

    return NextResponse.json(municipality)
  } catch (error) {
    Sentry.captureException(error, {
      tags: {
        endpoint: '/api/municipalities/[slug]',
        method: 'GET',
      },
      extra: {
        slug: params.slug,
        requestId,
      },
    })

    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
```

**Custom Error Classes with Sentry:**

```typescript
// lib/errors.ts
class MunicipalityError extends Error {
  readonly statusCode: number

  constructor(message: string, statusCode: number = 500) {
    super(message)
    this.name = 'MunicipalityError'
    this.statusCode = statusCode
  }
}

// app/api/municipalities/route.ts
try {
  if (!isValidSlug(params.slug)) {
    throw new MunicipalityError('Invalid slug format', 400)
  }

  const municipality = await fetchMunicipality(params.slug)

  if (!municipality) {
    throw new MunicipalityError('Municipality not found', 404)
  }

  return NextResponse.json(municipality)
} catch (error) {
  if (error instanceof MunicipalityError) {
    Sentry.captureException(error, {
      tags: { errorType: 'MunicipalityError', statusCode: error.statusCode },
      level: error.statusCode >= 500 ? 'error' : 'warning',
    })

    return NextResponse.json(
      { error: error.message },
      { status: error.statusCode }
    )
  }

  // Generic error
  Sentry.captureException(error)
  return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
}
```

## Release Tracking and Source Maps

Sentry release tracking correlates errors with git commits, enabling error trend analysis per release, automatic issue assignment, and regression detection.

**Automatic Release Tracking (withSentryConfig):**

```javascript
// next.config.js
const { withSentryConfig } = require('@sentry/nextjs')

module.exports = withSentryConfig(
  { /* Next.js config */ },
  {
    org: 'your-org',
    project: 'policy-node',
    authToken: process.env.SENTRY_AUTH_TOKEN,
    silent: true,
    widenClientFileUpload: true,  // Upload all source maps
    hideSourceMaps: true,  // Remove source maps from production bundle
  }
)
```

**Manual Release Creation:**

```bash
# Create release
npx sentry-cli releases new "$RELEASE_VERSION"

# Upload source maps
npx sentry-cli releases files "$RELEASE_VERSION" upload-sourcemaps ./out

# Finalize release
npx sentry-cli releases finalize "$RELEASE_VERSION"

# Associate commits (requires repository integration)
npx sentry-cli releases set-commits "$RELEASE_VERSION" --auto
```

**Release Comparison in Sentry UI:**
- New errors introduced in release
- Regression errors (previously fixed, now reappearing)
- Error-free rate per release (% of sessions without errors)
- Crash-free rate per release (% of sessions without crashes)

**Deployment Tracking:**

```bash
# Notify Sentry of deployment
npx sentry-cli releases deploys "$RELEASE_VERSION" new -e production
```

**Source Map Benefits:**
- Readable stack traces (original TypeScript/JSX line numbers)
- Variable names preserved (no minification obfuscation)
- File paths preserved (original file structure)
- Inline source code preview (view code around error line)

## Performance Monitoring

Sentry performance monitoring tracks API call duration, database query time, page load speed, and custom operation timing.

**Automatic Performance Tracking:**

```typescript
// sentry.client.config.ts
Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 0.1,  // 10% of transactions (reduce costs)
  integrations: [
    Sentry.browserTracingIntegration(),  // Automatic page load tracking
  ],
})
```

**Custom Performance Tracking:**

```typescript
import * as Sentry from '@sentry/nextjs'

async function fetchMunicipalities() {
  const transaction = Sentry.startTransaction({
    op: 'fetch',
    name: 'Fetch Municipalities',
  })

  try {
    const municipalities = await sanityClient.fetch(/* ... */)
    transaction.setTag('municipalityCount', municipalities.length)
    transaction.finish()  // Records duration
    return municipalities
  } catch (error) {
    transaction.setStatus('internal_error')
    transaction.finish()
    throw error
  }
}
```

**Database Query Spans:**

```typescript
async function fetchMunicipality(slug: string) {
  const transaction = Sentry.getCurrentHub().getScope()?.getTransaction()
  const span = transaction?.startChild({
    op: 'db.query',
    description: 'Fetch municipality by slug',
  })

  try {
    const municipality = await db.query(
      'SELECT * FROM municipalities WHERE slug = $1',
      [slug]
    )
    span?.setData('rowCount', municipality.rows.length)
    span?.finish()
    return municipality.rows[0]
  } catch (error) {
    span?.setStatus('internal_error')
    span?.finish()
    throw error
  }
}
```

**Performance Thresholds and Alerts:**
- Sentry UI: Set alerts for transactions >500ms
- Alerts sent to Slack when threshold exceeded
- Performance trends over time (p50, p75, p95, p99)

## Session Replay on Errors

Sentry session replay records user interactions (clicks, scrolls, navigation) and replays session when error occurs, providing visual context for error debugging.

**Session Replay Configuration:**

```typescript
// sentry.client.config.ts
Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  replaysOnErrorSampleRate: 1.0,  // 100% of error sessions
  replaysSessionSampleRate: 0.1,  // 10% of non-error sessions
  integrations: [
    Sentry.replayIntegration({
      maskAllText: true,  // Redact all text (PII protection)
      blockAllMedia: true,  // Block images/videos
      maskAllInputs: true,  // Redact input field values
    }),
  ],
})
```

**Privacy-Focused Replay Configuration:**

```typescript
Sentry.replayIntegration({
  // Mask PII
  maskAllText: true,
  maskAllInputs: true,
  blockAllMedia: true,

  // Unmask specific elements (non-sensitive UI)
  unblock: ['.public-header', '.navigation'],

  // Redact network request bodies
  networkDetailAllowUrls: [],
  networkCaptureBodies: false,
})
```

**Session Replay Features:**
- Visual playback of user actions before error
- Console logs shown in timeline
- Network requests shown in timeline
- DOM mutations recorded
- Privacy controls (mask text, inputs, media)

## Alerting and Notifications

Sentry alerts notify teams of new errors, error spikes, regression errors, and performance degradations via Slack, email, PagerDuty, or webhooks.

**Alert Types:**

1. **Issue Alerts:** Triggered when error occurs
   - First seen (new error type)
   - Error count exceeds threshold (10+ errors in 1 hour)
   - Users affected exceeds threshold (5+ users)
   - Error rate increase (2x spike compared to previous period)

2. **Metric Alerts:** Triggered by performance degradation
   - Transaction duration exceeds threshold (>500ms)
   - Error rate exceeds threshold (>1%)
   - Crash-free rate drops below threshold (<99%)

**Slack Integration:**

```yaml
# Sentry UI: Settings → Integrations → Slack
# Configure:
- Alert channel: #errors-production
- Alert conditions:
  - New error first seen
  - Error affects >5 users
  - Error count >10 in 1 hour
```

**Email Alerts:**

```yaml
# Sentry UI: Settings → Alerts → New Alert Rule
# Configure:
- Alert name: "High Error Rate - Production"
- Environment: production
- Condition: Error count >50 in 1 hour
- Notify: email → engineering@company.com
```

**PagerDuty Integration:**

```yaml
# Sentry UI: Settings → Integrations → PagerDuty
# Configure:
- Service: policy-node-production
- Alert conditions: Critical errors only (tagged critical=true)
```

## Codebase Patterns

**Current State (0% Adoption):**

```typescript
// Policy-node: 160 try/catch blocks, 116 console.error calls
catch (error) {
  console.error('Municipalities API error:', error)
}
// No error tracking, no alerting, no user context

// Helix: 1 try/catch block (commented-out logging)
catch (error) {
  // console.error(error)  ← Silent failure
}
// Zero visibility into production errors

// Kariusdx: 5 try/catch blocks, 0 console.error calls
catch (error) {
  // Silent catch (no logging, no tracking)
}
// Zero visibility into production errors
```

**Recommended Pattern:**

```typescript
import * as Sentry from '@sentry/nextjs'

try {
  await fetchMunicipalities()
} catch (error) {
  Sentry.captureException(error, {
    tags: {
      section: 'municipalities-api',
      operation: 'fetch',
      critical: 'true',
    },
    extra: {
      userId: session?.userId,
      municipalityId: params.slug,
    },
  })
  throw error  // Re-throw for error boundary to catch
}
```

**Adoption Summary:**
- Error tracking services: 0% (no Sentry, Rollbar, Bugsnag)
- Source map uploads: 0%
- Release tracking: 0%
- Performance monitoring: 0%
- Session replay: 0%
- Alerting: 0%

## Anti-Patterns

**1. Catching Errors Without Tracking:**
```typescript
// ❌ BAD: Catch error but don't track
catch (error) {
  console.error(error)
  return null
}
// Developers unaware of production errors
```

**2. Tracking Errors Without User Context:**
```typescript
// ❌ BAD: No user context
Sentry.captureException(error)

// ✅ GOOD: Include user context
Sentry.setUser({ id: session.userId, email: session.email })
Sentry.captureException(error)
```

**3. No Release Tracking:**
```typescript
// ❌ BAD: Errors not correlated with releases
// Cannot determine which deploy introduced error
```

**4. Excessive tracesSampleRate:**
```typescript
// ❌ BAD: 100% performance monitoring (expensive)
Sentry.init({ tracesSampleRate: 1.0 })

// ✅ GOOD: 10% sampling (sufficient for trends)
Sentry.init({ tracesSampleRate: 0.1 })
```

## Recommendations

**Priority 1: Install Sentry (All Repos)**
- Run `npx @sentry/wizard@latest -i nextjs`
- Configure SENTRY_DSN environment variable
- Add Sentry.setUser() at session initialization
- Integrate error.tsx with Sentry.captureException()

**Priority 2: Add User Context**
- Set user ID, email, role in Sentry.setUser()
- Track affected users per error
- Filter errors by user segment (admin, free, paid)

**Priority 3: Enable Release Tracking**
- Upload source maps automatically (withSentryConfig)
- Set release version from git commit SHA
- Track errors per release (regression detection)

**Priority 4: Configure Alerts**
- Slack alerts for new errors (first seen)
- Email alerts for high error rates (>10 errors/hour)
- PagerDuty for critical errors (tagged critical=true)

**Priority 5: Add Performance Monitoring**
- Set tracesSampleRate: 0.1 (10% sampling)
- Track slow API routes (>500ms)
- Monitor database query duration
